### 不变模式

不变（Immutable）模式是限制一个对象在被创建之后其状态就不再会发生变化，该对象可以被多个对象安全的共享，避免并发访问加锁的开销。在设计类的时候，除非对象状态确实有变化的必要，否则应该设计成不变模式。

不变模式因为不可变，所以对象更加易于维护，且是线程安全的，但是缺点也是显而易见的。如果需要修改一个不变对象，就只能通过创建新的对象来达到目的，这在需要频繁修改的场景下就会创建大量对象。例如，在 java 8 之前不推荐在 for 循环中使用 `+` 操作符去拼接字符串就是出于这一考虑。

不变模式分为 __弱不变模式__ 和 __强不变模式__。

#### 弱不变模式

在弱不变模式中，一个类对象在被构造出来之后，其状态是不可以被改变的，但是子类的对象可以具备变化的状态。

满足弱不变模式条件的类，在实现上需要具备以下特点：

1. 类没有任何方法可以修改对象的状态，当对象被构造出来之后便不能再被改变。
2. 所有的属性都是私有的，不声明任何公开的属性。
3. 如果该类对象引用了可变对象，则需要保证这些可变对象不能被外界访问。一般建议尽量在不变对象内部实例化这些可变对象，如果不得以非要由构造方法传入，则应该在构造不变对象时复制一份对应的可变对象。

弱不变模式的缺点：

1. 弱不变对象的子对象可以是可变的。
2. 可变子对象可以修改不变父对象的状态，从而间接让外界修改该不变对象的状态。

#### 强不变模式

满足强不变模式条件的类，不光其自身对象是不可变的，而且子类对象也是不可变的。在实现上，满足强不变模式条件的类不光要具备弱不变模式全部的特点，还要额外满足以下要求：

1. 所有的方法都是 final 修饰的，确保不会被覆盖。
2. 类本身也是 final 类型的，限制类不可以被继承。

示例实现：

```java
public final class ImmutableClass {  // 类应该用final修饰，防止被继承

    /* 所有的属性都应该设置为私有 */

    private Integer a;
    private Double b;
    private String c;

    /**
     * 通过构造方法来实例化对象，如果传入的对象是可变的，则需要复制一份
     */
    public ImmutableClass(Integer a, Double b, String c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    /* 所有非私有的方法都需要加 final 修饰，避免覆盖 */

    public final Integer getA() {
        return a;
    }

    public final Double getB() {
        return b;
    }

    public final String getC() {
        return c;
    }

}
```
