## 享元模式

__以共享的方式支持大量的细粒度对象__，能做到共享的关键是区分内部状态（Internal State）和外部状态（External State）。

__内部状态__：存储在享元对象内部，且不会随环境改变而有所不同的状态。

__外部状态__：随环境改变而改变，不可以共享的状态，必须由客户端保存，并在享元对象被创建之后，在需要使用的时候以参数形式传入到享元对象内部。

__外部状态不可以影响享元对象的内部状态，即外部状态和内部状态是独立的__。

享元模式就是将内部状态分离出来共享，称之为享元，通过共享享元对象来减少内存的占用，并将外部状态分离出来，放到外部让客户端去维护，并在需要的时候传递给享元对象使用。

享元模式分为 __单纯享元模式__ 和 __复合享元模式__。

### 单纯享元模式

__所涉及的角色__：

- 抽象享元

此角色是所有具体享元的超类，规定了具体享元需要实现的公共接口。

- 具体享元

实现了抽象享元的具体的类，如果有内部状态的话，必须为内部状态提供存储空间。

- 享元工厂

负责创建和管理享元角色，需要保证享元角色被适当的共享，当客户端需要一个享元对象的时候，工厂需要检查是否有已定义的合适的对象可供使用，如果没有则创建新的享元对象。

- 客户端

维护一个对所有享元对象的引用，自行存储所有享元对象的外部状态。客户端不可以直接创建享元对象实例，而必须从工厂中获取。

### 复合享元模式

__所涉及的角色__：

- 抽象享元

- 具体享元

- 复合享元

复合享元所代表的对象是不可以共享的（所以也称作不可共享的享元对象），一个复合享元对象可以分解成多个单纯享元对象。

具有以下两个责任：

1. 由单纯的享元对象复合而成，因此需要提供 `add()` 这样的聚集管理方法，一个复合对象具有不同的聚集，并且可以在对象创建之后被修改，所以复合对象的状态是可变的，也就不可共享的。

2. 复合享元对象实现了抽象享元接口

- 享元工厂

- 客户端

### 享元模式的应用场景

满足下列所有条件时，可以考虑使用享元模式：

> 1. 一个系统有大量的对象
> 2. 这些对象消耗着大量的内存
> 3. 这些对象中的大部分都可以外部化
> 4. 这些对象可以按照内部状态分成很多的组，当把外部对象从对象中剔除时，每一个组都可以仅用一个对象表示
> 5. 软件对象不依赖于这些对象的身份，即这些对象是不可分辨的

### 享元模式的优缺点

- 优点

大幅度降低了内存中对象的数量

- 缺点

系统设计更加复杂，将享元独享的状态外部化，拉长运行时间